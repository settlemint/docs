---
title: "Introduction"
description: Overview of EVM and Fabric contract templates
---

import { Tab, Tabs } from "fumadocs-ui/components/tabs";
import { Callout } from "fumadocs-ui/components/callout";
import { Card } from "fumadocs-ui/components/card";

## Smart Contract & Chaincode Templates (EVM & Fabric)

- **EVM-compatible networks** using **Solidity** (e.g., Ethereum, Besu, Quorum
  Polygon, Avalanche)
- **Hyperledger Fabric** networks using **GoLang** and **TypeScript**

These templates are crafted for developers looking to **accelerate smart
contract or chaincode development**, ensure **security alignment**, and
streamline **integration with middleware, APIs, and off-chain systems**.

---

## What Are These Templates?

These are **starter libraries** built with industry-relevant design patterns and
reusable code components. Each one includes:

### EVM Templates (Solidity + TypeScript)

- Core Solidity contracts structured for modular deployment
- Built-in patterns like Ownable, role-based access control, and event logging
- TypeScript SDK bindings for contract interaction and deployment

### Fabric Templates (GoLang + TypeScript)

- GoLang-based chaincode modules for key-value data storage, access control, and
  function invocation
- Transaction flow patterns using Fabric Contract API
- TypeScript client SDKs for ledger access, endorsement submission, and result
  handling

Each template is intended to work as a **scaffold**, allowing developers to
focus on **domain logic**, not base plumbing.

---

## What Do These Templates Help With?

By using these templates, you will:

- Avoid writing redundant boilerplate for state reads/writes, ACLs, and access
  layers
- Kick-start **full-stack blockchain workflows** with backend, smart contracts,
  and integration layers
- Implement **clean separation of concerns** between business logic and system
  orchestration
- Follow best practices for security, gas/resource efficiency, and observability
- Accelerate delivery of POCs, MVPs, or production-grade logic

---

SettleMint's smart contract templates serve as open-source, ready-to-use
foundations for blockchain application development, significantly accelerating
the deployment process. These templates enable users to quickly customize and
extend their blockchain applications, leveraging tested and community-enhanced
frameworks to reduce development time and accelerate market entry.

## Open-source smart contract templates under the MIT license

Benefit from the expertise of the blockchain community and trust in the
reliability of your smart contracts. These templates are vetted and used by
major enterprises and institutions, ensuring enhanced security and confidence in
your deployments.

## Template library

The programming languages for smart contracts differ depending on the protocol:

- For **EVM-compatible networks** (like Ethereum), smart contracts are written
  in **Solidity**.
- For **Hyperledger Fabric**, smart contracts (also called chaincode) are
  written in **TypeScript** or **Go**.

---

### Solidity contracts IDE

| Template                                                                                    | Description                               |
| ------------------------------------------------------------------------------------------- | ----------------------------------------- |
| [Empty](https://github.com/settlemint/solidity-empty)                                       | A minimal smart contract in Solidity      |
| [ERC20 Token](https://github.com/settlemint/solidity-token-erc20)                           | Standard ERC20 token implementation       |
| [ERC20 with MetaTx](https://github.com/settlemint/solidity-token-erc20-metatx)              | ERC20 token with meta-transaction support |
| [ERC20 with Crowdsale](https://github.com/settlemint/solidity-token-erc20-crowdsale)        | ERC20 token with integrated crowdsale     |
| [ERC1155 Token](https://github.com/settlemint/solidity-token-erc1155)                       | Multi-token standard (ERC1155)            |
| [ERC721](https://github.com/settlemint/solidity-token-erc721)                               | Standard NFT token (ERC721)               |
| [ERC721a](https://github.com/settlemint/solidity-token-erc721a)                             | Gas-optimized NFT (ERC721A)               |
| [ERC721 Generative Art](https://github.com/settlemint/solidity-token-erc721-generative-art) | NFT with generative art logic             |
| [Soulbound Token](https://github.com/settlemint/solidity-token-soulbound)                   | Non-transferable token                    |
| [Supply Chain](https://github.com/settlemint/solidity-supplychain)                          | Asset tracking across supply chain        |
| [State Machine](https://github.com/settlemint/solidity-statemachine)                        | State transition logic                    |
| [Diamond Bond](https://github.com/settlemint/solidity-diamond-bond)                         | Bond issuance and tracking                |
| [Attestation Service](https://github.com/settlemint/solidity-attestation-service)           | Verifiable claim attestations             |

---

### Chaincode templates (hyperledger fabric)

| Template                                                                                    | Description                              |
| ------------------------------------------------------------------------------------------- | ---------------------------------------- |
| [Empty (TypeScript)](https://github.com/settlemint/chaincode-typescript-empty)              | Minimal TypeScript chaincode             |
| [Empty with PDC (TypeScript)](https://github.com/settlemint/chaincode-typescript-empty-pdc) | Chaincode using private data collections |
| [Empty (Go)](https://github.com/settlemint/chaincode-go-empty)                              | Minimal Go chaincode                     |

---

## Important Notes Before Usage

<Callout type="warning" title="Please review before use">
  These templates are <strong>reference implementations</strong>, not
  ready-to-deploy production contracts or chaincode. Always customize and test
  thoroughly before using in any live or sensitive environment.
</Callout>

**Key cautions:**

- **Security**: Templates should be audited for your use case and environment
  specifics. Critical paths like funds transfer or permission control must be
  reviewed manually and/or formally verified.
- **Customization Required**: The templates are generic. Specific business
  logic, regulatory constraints, and contract-specific behaviors must be
  implemented manually.
- **Resource Considerations**: Smart contract templates must be gas-efficient
  (EVM), and Fabric templates must avoid long execution or response times due to
  chaincode lifecycle constraints.
- **Environment Sensitivity**: Test on devnets (e.g., Ganache, local Fabric)
  before deploying on public/mainnet infrastructure.

---

## Best Practices for Template Adoption

### 1. **Separate Core Logic and Permissions**

- Define role-based modifiers (Solidity) or access logic (GoLang) as reusable
  layers
- Avoid embedded ACLs in core business functions to maintain clarity and
  auditability

### 2. **Follow Transactional Boundaries**

- In Fabric: Avoid multiple read/write invocations inside a loop unless
  atomicity is ensured
- In EVM: Minimize state changes per call to avoid unnecessary gas consumption
  or complexity

### 3. **Structure Events Consistently**

- Use semantic, structured event naming (`ProfileCreated`, `AssetTransferred`)
- Emit key identifiers and indexes for off-chain sync and indexing systems
  (e.g., The Graph, Kafka listeners)

### 4. **Leverage Strong Typing in TypeScript SDKs**

- Use typed interfaces for contract interaction and payload schemas
- Ensure runtime error handling for all transaction submission flows and network
  responses

### 5. **Use Version Control for Models**

- Store contract/chaincode hashes and deployment metadata
- Implement migration logic for versioned schema changes in smart contracts or
  ledger records

### 6. **Align With CI/CD and Test Frameworks**

- Add unit and integration tests with frameworks like Mocha, Chai, Jest (for
  TS), and Go test (for Fabric)
- Include basic gas profiling or peer endorsement simulations
- Use GitHub Actions, GitLab CI, or similar for continuous checks

### 7. **Adopt Secure Development Patterns**

- Avoid dynamic `delegatecall` or unbounded loops in Solidity
- Use Fabric's built-in MSP identity abstraction for managing user roles
- Sanitize and validate all inputs rigorously, both on-chain and at the API
  level

---

## Languages & Tooling Used

| Template Layer        | Language   | Usage                               |
| --------------------- | ---------- | ----------------------------------- |
| Smart Contracts (EVM) | Solidity   | Core business logic on-chain        |
| Chaincode (Fabric)    | GoLang     | Permissioned chain logic            |
| Integration Layer     | TypeScript | Contract calls, event listeners, UI |

---

## What's Next?

You can now browse specific templates in:

- `EVM Contracts` (Solidity)
- `Fabric Chaincode` (GoLang + TypeScript)

The smart contract and chaincode libraries aim to help developers and teams:

- Move from zero to working logic quickly
- Avoid reinventing core state and ACL patterns
- Align with best practices across Solidity, GoLang, and TypeScript
- Establish a common starting point for internal or client-facing solutions

Use them as a **launchpad**, not an endpoint , always customize to your
environment, test with realistic data, and plan for maintainability and audit
readiness.
