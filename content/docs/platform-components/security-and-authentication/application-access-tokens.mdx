---
title: "Application access tokens"
description: Secure, granular API authentication for production applications with scoped permissions and automated token management
---

import { Tabs, Tab } from "fumadocs-ui/components/tabs";
import { Callout } from "fumadocs-ui/components/callout";
import { Steps } from "fumadocs-ui/components/steps";
import { Card } from "fumadocs-ui/components/card";

Application access tokens provide granular API security for production applications in SettleMint. Unlike personal access tokens which represent individual users, application access tokens represent your applications and services, enabling secure machine-to-machine authentication with fine-grained permission control.

## Overview

Application access tokens are designed for production environments where you need:

- **Service-specific access control** - Grant access only to the specific services your application needs
- **Automated token rotation** - Implement security best practices with programmatic token management
- **Audit compliance** - Track all API usage at the application level for security and compliance
- **Zero-trust security** - Follow the principle of least privilege with scoped permissions

### Key benefits

<div className="grid grid-cols-1 md:grid-cols-2 gap-4 mt-4">
  <Card title="Granular permissions" description="Control access at the service level, ensuring applications only access what they need" />
  <Card title="Production-ready" description="Built for high-availability production environments with robust error handling" />
  <Card title="Compliance-friendly" description="Full audit trails and access logs for regulatory compliance" />
  <Card title="Flexible integration" description="Multiple authentication methods to fit your architecture" />
</div>

## Application tokens vs Personal tokens

Understanding when to use application access tokens versus personal access tokens is crucial for security:

| Feature | Application Access Tokens | Personal Access Tokens |
|---------|--------------------------|----------------------|
| **Purpose** | Machine-to-machine authentication | User-specific authentication |
| **Scope** | Service-level permissions | User-level permissions |
| **Rotation** | Programmatic rotation supported | Manual rotation required |
| **Audit trail** | Application-level tracking | User-level tracking |
| **Use case** | Production applications, CI/CD | Development, testing, personal scripts |

<Callout type="info">
  **Best practice**: Always use application access tokens for production workloads and automated systems. Personal access tokens should only be used for development and testing.
</Callout>

## Scoped permissions system

SettleMint's scoped permissions system allows you to implement the principle of least privilege by granting tokens access only to the specific services they need.

### Scope types

<Tabs items={["All services", "Specific services"]}>
  <Tab value="All services">
    **Use case**: Applications that need comprehensive access to all current and future services
    
    - Grants access to all services within the application
    - Automatically includes new services added to the application
    - Ideal for administrative tools or comprehensive monitoring systems
    - Reduces management overhead but increases security exposure
  </Tab>
  
  <Tab value="Specific services">
    **Use case**: Production applications with well-defined service requirements
    
    - Grants access only to explicitly selected services
    - Requires manual updates when new services are needed
    - Follows security best practices for production environments
    - Enables fine-grained access control and audit trails
  </Tab>
</Tabs>

### Service-specific access control

Each service type in SettleMint has specific access patterns:

- **Blockchain nodes**: Full JSON-RPC access to the selected nodes
- **Smart contract APIs**: RESTful and GraphQL access to deployed contracts
- **IPFS storage**: Read/write access to distributed storage
- **Graph indexers**: Query access to indexed blockchain data
- **Integration services**: Access to custom middleware and integrations

## CLI setup

Before creating tokens via CLI, ensure you have the SettleMint CLI installed and configured:

```bash
# Install the SettleMint CLI
curl -sSL https://cli.settlemint.com/install.sh | sh

# Add to PATH (if not done automatically)
export PATH="$HOME/.settlemint/bin:$PATH"

# Authenticate with your SettleMint account
settlemint auth login

# Verify installation
settlemint --version
```

<Callout type="info">
  **Pro tip**: Add the SettleMint CLI to your CI/CD environment for automated token management. Store your API key as a secret variable.
</Callout>

## Create an application access token

You can create application access tokens using the SettleMint CLI or the web interface. The CLI is recommended for automation and production deployments.

### Using the CLI

The SettleMint CLI provides powerful commands for creating and managing application access tokens programmatically:

<Tabs items={["Basic token", "Scoped token", "Advanced options"]}>
  <Tab value="Basic token">
    Create a basic application token with access to all services:
    
    ```bash
    # Create a token with access to all services
    settlemint token create \
      --application "my-app-id" \
      --name "prod-api-client" \
      --description "Production API client token"
    
    # The token will be displayed once - save it securely!
    # Example output:
    # âœ“ Token created successfully
    # Token: settlemint_app_k3y_abcd1234...
    # Token ID: tok_1234567890
    ```
  </Tab>
  
  <Tab value="Scoped token">
    Create a token with specific service permissions:
    
    ```bash
    # Create a token with specific service access
    settlemint token create \
      --application "my-app-id" \
      --name "prod-indexer-client" \
      --description "Production indexer access only" \
      --scope specific \
      --services "node-ethereum-mainnet,graph-indexer-prod"
    
    # List available services for scoping
    settlemint services list --application "my-app-id"
    ```
  </Tab>
  
  <Tab value="Advanced options">
    Create tokens with advanced configuration:
    
    ```bash
    # Create a token with custom expiration
    settlemint token create \
      --application "my-app-id" \
      --name "temporary-migration-token" \
      --description "Token for data migration" \
      --expires "2024-12-31T23:59:59Z" \
      --scope specific \
      --services "ipfs-storage,node-polygon"
    
    # Create a token and save to environment file
    settlemint token create \
      --application "my-app-id" \
      --name "dev-environment" \
      --output env > .env
    
    # Create a token and save to secret manager
    settlemint token create \
      --application "my-app-id" \
      --name "prod-token" \
      --output json | jq -r '.token' | \
      aws secretsmanager create-secret \
        --name settlemint/prod-token \
        --secret-string file:///dev/stdin
    ```
  </Tab>
</Tabs>

### CLI token management commands

```bash
# List all tokens for an application
settlemint token list --application "my-app-id"

# View token details (without exposing the token value)
settlemint token describe --token-id "tok_1234567890"

# Update token scope
settlemint token update \
  --token-id "tok_1234567890" \
  --add-services "new-service-1,new-service-2" \
  --remove-services "old-service"

# Delete a token
settlemint token delete --token-id "tok_1234567890" --confirm

# Rotate a token (creates new, schedules old for deletion)
settlemint token rotate \
  --token-id "tok_1234567890" \
  --grace-period "1h"
```

### CLI automation examples

<Tabs items={["CI/CD integration", "Kubernetes secrets", "Docker compose"]}>
  <Tab value="CI/CD integration">
    **GitHub Actions example:**
    
    ```yaml
    name: Deploy to Production
    on:
      push:
        branches: [main]
    
    jobs:
      deploy:
        runs-on: ubuntu-latest
        steps:
          - uses: actions/checkout@v3
          
          - name: Install SettleMint CLI
            run: |
              curl -sSL https://cli.settlemint.com/install.sh | sh
              echo "$HOME/.settlemint/bin" >> $GITHUB_PATH
          
          - name: Create deployment token
            env:
              SETTLEMINT_API_KEY: ${{ secrets.SETTLEMINT_API_KEY }}
            run: |
              # Create a new token for this deployment
              TOKEN=$(settlemint token create \
                --application "${{ vars.APP_ID }}" \
                --name "deploy-${{ github.run_number }}" \
                --description "Automated deployment token" \
                --scope specific \
                --services "${{ vars.REQUIRED_SERVICES }}" \
                --output json | jq -r '.token')
              
              # Save token as masked output
              echo "::add-mask::$TOKEN"
              echo "SETTLEMINT_TOKEN=$TOKEN" >> $GITHUB_ENV
          
          - name: Deploy application
            run: |
              # Your deployment commands here
              ./deploy.sh
          
          - name: Cleanup old tokens
            if: always()
            run: |
              # Remove tokens older than 7 days
              settlemint token list \
                --application "${{ vars.APP_ID }}" \
                --format json | \
              jq -r '.[] | select(.created_at < (now - 604800)) | .id' | \
              xargs -I {} settlemint token delete --token-id {} --confirm
    ```
  </Tab>
  
  <Tab value="Kubernetes secrets">
    **Create and store tokens in Kubernetes:**
    
    ```bash
    #!/bin/bash
    # create-k8s-token.sh
    
    # Set variables
    APP_ID="my-app-id"
    NAMESPACE="production"
    SECRET_NAME="settlemint-token"
    
    # Create token with specific services
    echo "Creating SettleMint application token..."
    TOKEN_JSON=$(settlemint token create \
      --application "$APP_ID" \
      --name "k8s-prod-$(date +%Y%m%d)" \
      --description "Kubernetes production token" \
      --scope specific \
      --services "node-ethereum,ipfs-storage,graph-indexer" \
      --output json)
    
    # Extract token value
    TOKEN=$(echo "$TOKEN_JSON" | jq -r '.token')
    TOKEN_ID=$(echo "$TOKEN_JSON" | jq -r '.id')
    
    # Create Kubernetes secret
    kubectl create secret generic $SECRET_NAME \
      --from-literal=token="$TOKEN" \
      --from-literal=token_id="$TOKEN_ID" \
      --namespace=$NAMESPACE \
      --dry-run=client -o yaml | kubectl apply -f -
    
    # Label the secret for easy management
    kubectl label secret $SECRET_NAME \
      app=settlemint \
      token-id="$TOKEN_ID" \
      created="$(date -u +%Y-%m-%dT%H:%M:%SZ)" \
      --namespace=$NAMESPACE
    
    echo "Token created and stored in Kubernetes secret: $SECRET_NAME"
    ```
    
    **Use in deployment:**
    
    ```yaml
    apiVersion: apps/v1
    kind: Deployment
    metadata:
      name: blockchain-api
    spec:
      template:
        spec:
          containers:
          - name: api
            image: myapp:latest
            env:
            - name: SETTLEMINT_TOKEN
              valueFrom:
                secretKeyRef:
                  name: settlemint-token
                  key: token
    ```
  </Tab>
  
  <Tab value="Docker compose">
    **Automated token management for Docker:**
    
    ```bash
    #!/bin/bash
    # setup-docker-tokens.sh
    
    # Check if .env file exists
    if [ -f .env ]; then
      source .env
    fi
    
    # Create token if not exists or expired
    if [ -z "$SETTLEMINT_TOKEN" ] || ! settlemint token describe --token-id "$SETTLEMINT_TOKEN_ID" &>/dev/null; then
      echo "Creating new SettleMint token..."
      
      # Create token
      TOKEN_OUTPUT=$(settlemint token create \
        --application "$SETTLEMINT_APP_ID" \
        --name "docker-$(hostname)-$(date +%Y%m%d)" \
        --description "Docker compose token for $(hostname)" \
        --scope specific \
        --services "$(cat .settlemint-services)" \
        --output json)
      
      # Update .env file
      {
        echo "# Generated by setup-docker-tokens.sh on $(date)"
        echo "SETTLEMINT_TOKEN=$(echo $TOKEN_OUTPUT | jq -r '.token')"
        echo "SETTLEMINT_TOKEN_ID=$(echo $TOKEN_OUTPUT | jq -r '.id')"
        echo "SETTLEMINT_TOKEN_CREATED=$(date -u +%Y-%m-%dT%H:%M:%SZ)"
      } > .env.settlemint
      
      # Merge with existing .env
      grep -v "^SETTLEMINT_" .env > .env.tmp || true
      cat .env.tmp .env.settlemint > .env
      rm .env.tmp .env.settlemint
      
      echo "âœ“ Token created and saved to .env"
    else
      echo "âœ“ Existing token is valid"
    fi
    
    # Start services
    docker-compose up -d
    ```
    
    **docker-compose.yml:**
    
    ```yaml
    version: '3.8'
    services:
      blockchain-indexer:
        image: myapp/indexer:latest
        env_file: .env
        environment:
          - NODE_URL=https://node.settlemint.com
          - IPFS_URL=https://ipfs.settlemint.com
        deploy:
          restart_policy:
            condition: any
            delay: 5s
    ```
  </Tab>
</Tabs>

### Token naming conventions

Follow these naming conventions for better token management:

```
<environment>-<application>-<purpose>
```

Examples:
- `prod-webapp-api-access`
- `staging-etl-pipeline-reader`
- `dev-integration-tests`

### Using the web interface

While the CLI is recommended for automation, you can also create tokens through the web interface:

<Steps>
  <step>
    ### Navigate to application tokens
    
    Go to your application's dashboard and click on "App access tokens" in the left navigation.
  </step>
  
  <step>
    ### Configure token settings
    
    Click "Add an application access token" and configure:
    
    - **Name**: A descriptive identifier for the token (e.g., `production-api-client`)
    - **Expiration**: Set an appropriate lifetime based on your security policy
    - **Description**: Document the token's purpose for future reference
  </step>
  
  <step>
    ### Set permissions scope
    
    Choose between:
    
    - **All services**: For administrative or development use
    - **Specific services**: For production applications (recommended)
    
    If selecting specific services, carefully choose only the services your application requires.
  </step>
  
  <step>
    ### Generate and secure the token
    
    Click **Confirm** to generate the token. 
    
    <Callout type="error">
      **Critical**: Copy and securely store your token immediately. For security reasons, it will never be displayed again. If lost, you must create a new token.
    </Callout>
  </step>
</Steps>

## Token rotation procedures

Regular token rotation is a critical security practice for production environments. SettleMint supports zero-downtime token rotation.

### Rotation strategy

<Steps>
  <step>
    ### Create new token
    
    Create a new application access token with the same permissions as the existing token. Use a naming convention that includes version numbers:
    - `prod-api-v2-2024-01`
  </step>
  
  <step>
    ### Deploy in parallel
    
    Update your application configuration to support multiple tokens during the transition period. This ensures zero downtime.
  </step>
  
  <step>
    ### Verify new token
    
    Test the new token in your staging environment before production deployment.
  </step>
  
  <step>
    ### Decommission old token
    
    Once all systems are using the new token, delete the old token through the SettleMint dashboard.
  </step>
</Steps>

### Automated rotation

For enhanced security, implement automated token rotation:

```javascript
// Token rotation scheduler example
const rotateApplicationToken = async () => {
  // 1. Create new token via SettleMint API
  const newToken = await createApplicationToken({
    name: `prod-api-v${Date.now()}`,
    scope: 'specific',
    services: ['node-1', 'ipfs-storage', 'graph-indexer']
  });
  
  // 2. Update application configuration
  await updateEnvironmentVariable('SETTLEMINT_TOKEN', newToken);
  
  // 3. Verify new token is working
  await verifyTokenAccess(newToken);
  
  // 4. Schedule old token deletion
  setTimeout(() => deleteOldToken(currentToken), 3600000); // 1 hour grace period
};
```

## Update an application access token

You can modify the scope of existing tokens without regenerating them, maintaining service continuity.

<Steps>
  <step>
    Navigate to your application dashboard and click **App Access Tokens** in the left navigation.
  </step>
  
  <step>
    Click **View scopes** next to the token you want to modify to review current permissions.
  </step>
  
  <step>
    Click **Update** to modify the token's scope. Add or remove services as needed.
  </step>
  
  <step>
    Click **Confirm** to apply the changes. The update takes effect immediately.
  </step>
</Steps>

<Callout type="info">
  **Note**: You cannot change a token's expiration date after creation. To extend a token's lifetime, create a new token and implement rotation.
</Callout>

## Delete an application access token

Immediate token revocation is essential when dealing with potential security incidents.

<Steps>
  <step>
    Navigate to the application dashboard and click **App Access Tokens**.
  </step>
  
  <step>
    Locate the compromised or unused token and click **Delete**.
  </step>
  
  <step>
    Type **DELETE** to confirm. The token is immediately invalidated across all services.
  </step>
</Steps>

<Callout type="warning">
  **Security incident response**: If you suspect a token has been compromised, delete it immediately and review your audit logs for any unauthorized access.
</Callout>

## Using application access tokens

SettleMint supports multiple authentication methods to accommodate different architectural patterns and security requirements.

### Authentication methods

<Tabs items={["Header authentication", "Query parameter", "URL path"]}>
  <Tab value="Header authentication">
    **Recommended for production use**
    
    ```javascript
    // Using fetch API
    const response = await fetch('https://node-1.settlemint.com', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'x-auth-token': 'your-application-token'
      },
      body: JSON.stringify({
        jsonrpc: '2.0',
        method: 'eth_blockNumber',
        params: [],
        id: 1
      })
    });
    
    // Using axios
    const axios = require('axios');
    const client = axios.create({
      headers: {
        'x-auth-token': 'your-application-token'
      }
    });
    ```
    
    **Advantages**:
    - Tokens are not exposed in logs or URLs
    - Works with all HTTP methods
    - Industry-standard approach
  </Tab>
  
  <Tab value="Query parameter">
    **Use for webhooks and third-party integrations**
    
    ```javascript
    // Query parameter authentication
    const url = 'https://api.settlemint.com/graphql?token=your-application-token';
    
    // Example with webhook configuration
    const webhookConfig = {
      url: 'https://ipfs.settlemint.com/api/v0/add?token=your-application-token',
      method: 'POST'
    };
    ```
    
    **Advantages**:
    - Works with services that don't support custom headers
    - Easy integration with third-party webhook systems
    
    **Cautions**:
    - Tokens may appear in server logs
    - Use only when header authentication is not possible
  </Tab>
  
  <Tab value="URL path">
    **Legacy compatibility mode**
    
    ```javascript
    // URL path authentication
    const ipfsUrl = 'https://ipfs.settlemint.com/your-application-token/api/v0/cat';
    const avalancheUrl = 'https://avalanche.settlemint.com/ext/bc/C/rpc/your-application-token';
    
    // Web3 provider example
    const Web3 = require('web3');
    const web3 = new Web3('https://node.settlemint.com/your-application-token');
    ```
    
    **Special cases**:
    - IPFS: `https://service.settlemint.com/TOKEN/api/v0/...`
    - Avalanche: `https://service.settlemint.com/ext/bc/C/rpc/TOKEN`
    
    **Cautions**:
    - Consider migrating to header-based authentication
    - May not be supported in future versions
  </Tab>
</Tabs>

### Code examples by service type

<Tabs items={["Blockchain nodes", "Smart contracts", "IPFS storage", "Graph indexers"]}>
  <Tab value="Blockchain nodes">
    **Web3.js example:**
    
    ```javascript
    const Web3 = require('web3');
    
    // Initialize Web3 with authentication header
    const web3 = new Web3(new Web3.providers.HttpProvider('https://node.settlemint.com', {
      headers: [
        { name: 'x-auth-token', value: process.env.SETTLEMINT_APP_TOKEN }
      ]
    }));
    
    // Get current block number
    const blockNumber = await web3.eth.getBlockNumber();
    
    // Get account balance
    const balance = await web3.eth.getBalance('0x742d35Cc6634C0532925a3b844Bc9e7595f2bD40');
    console.log('Balance:', web3.utils.fromWei(balance, 'ether'), 'ETH');
    
    // Send transaction
    const tx = {
      from: '0xYourAddress',
      to: '0xRecipientAddress',
      value: web3.utils.toWei('0.1', 'ether'),
      gas: 21000
    };
    const receipt = await web3.eth.sendTransaction(tx);
    ```
    
    **Ethers.js v6 example:**
    
    ```javascript
    const { ethers } = require('ethers');
    
    // Create custom fetcher with auth header
    const customFetchRequest = new ethers.FetchRequest('https://node.settlemint.com');
    customFetchRequest.setHeader('x-auth-token', process.env.SETTLEMINT_APP_TOKEN);
    
    // Initialize provider
    const provider = new ethers.JsonRpcProvider(customFetchRequest);
    
    // Query blockchain
    const blockNumber = await provider.getBlockNumber();
    const balance = await provider.getBalance('0x742d35Cc6634C0532925a3b844Bc9e7595f2bD40');
    
    // Create wallet for transactions
    const wallet = new ethers.Wallet(process.env.PRIVATE_KEY, provider);
    const tx = await wallet.sendTransaction({
      to: '0xRecipientAddress',
      value: ethers.parseEther('0.1')
    });
    await tx.wait();
    ```
    
    **Viem example:**
    
    ```javascript
    const { createPublicClient, createWalletClient, http } = require('viem');
    const { mainnet } = require('viem/chains');
    
    // Public client for reading
    const publicClient = createPublicClient({
      chain: mainnet,
      transport: http('https://node.settlemint.com', {
        fetchOptions: {
          headers: {
            'x-auth-token': process.env.SETTLEMINT_APP_TOKEN
          }
        }
      })
    });
    
    // Get block number
    const blockNumber = await publicClient.getBlockNumber();
    
    // Read contract
    const balance = await publicClient.readContract({
      address: '0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48',
      abi: erc20ABI,
      functionName: 'balanceOf',
      args: ['0x742d35Cc6634C0532925a3b844Bc9e7595f2bD40']
    });
    ```
  </Tab>
  
  <Tab value="Smart contracts">
    **GraphQL API example:**
    
    ```javascript
    const { GraphQLClient } = require('graphql-request');
    
    // Initialize GraphQL client
    const client = new GraphQLClient('https://api-portal.settlemint.com/graphql', {
      headers: {
        'x-auth-token': process.env.SETTLEMINT_APP_TOKEN
      }
    });
    
    // Query token balances
    const query = `
      query GetTokenInfo($address: String!, $tokenAddress: String!) {
        tokenBalance(address: $address, tokenAddress: $tokenAddress) {
          balance
          symbol
          decimals
          formattedBalance
        }
        tokenMetadata(address: $tokenAddress) {
          name
          totalSupply
          owner
        }
      }
    `;
    
    const data = await client.request(query, {
      address: '0xYourWalletAddress',
      tokenAddress: '0xTokenContractAddress'
    });
    
    // Execute mutations
    const mutation = `
      mutation TransferToken($to: String!, $amount: String!) {
        transfer(to: $to, amount: $amount) {
          transactionHash
          status
          gasUsed
        }
      }
    `;
    
    const result = await client.request(mutation, {
      to: '0xRecipientAddress',
      amount: '1000000000000000000' // 1 token with 18 decimals
    });
    ```
    
    **REST API example:**
    
    ```javascript
    // Call smart contract function via REST
    const response = await fetch('https://api-portal.settlemint.com/contracts/erc20/balanceOf', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'x-auth-token': process.env.SETTLEMINT_APP_TOKEN
      },
      body: JSON.stringify({
        contractAddress: '0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48',
        address: '0x742d35Cc6634C0532925a3b844Bc9e7595f2bD40'
      })
    });
    
    const { balance, formatted } = await response.json();
    console.log(`Balance: ${formatted}`);
    
    // Batch operations
    const batchResponse = await fetch('https://api-portal.settlemint.com/batch', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'x-auth-token': process.env.SETTLEMINT_APP_TOKEN
      },
      body: JSON.stringify({
        requests: [
          { method: 'balanceOf', params: { address: '0xAddress1' } },
          { method: 'balanceOf', params: { address: '0xAddress2' } },
          { method: 'totalSupply', params: {} }
        ]
      })
    });
    ```
  </Tab>
  
  <Tab value="IPFS storage">
    **File upload example:**
    
    ```javascript
    const FormData = require('form-data');
    const fs = require('fs');
    const axios = require('axios');
    
    // Upload single file
    async function uploadFile(filePath) {
      const form = new FormData();
      form.append('file', fs.createReadStream(filePath));
      
      const response = await axios.post('https://ipfs.settlemint.com/api/v0/add', form, {
        headers: {
          'x-auth-token': process.env.SETTLEMINT_APP_TOKEN,
          ...form.getHeaders()
        }
      });
      
      return response.data.Hash;
    }
    
    // Upload directory
    async function uploadDirectory(dirPath) {
      const form = new FormData();
      
      // Add all files in directory
      const files = fs.readdirSync(dirPath);
      files.forEach(file => {
        form.append('file', fs.createReadStream(`${dirPath}/${file}`), {
          filepath: file
        });
      });
      
      const response = await axios.post('https://ipfs.settlemint.com/api/v0/add?wrap-with-directory=true', form, {
        headers: {
          'x-auth-token': process.env.SETTLEMINT_APP_TOKEN,
          ...form.getHeaders()
        }
      });
      
      return response.data;
    }
    
    // Pin management
    async function pinHash(hash) {
      const response = await axios.post('https://ipfs.settlemint.com/api/v0/pin/add', null, {
        params: { arg: hash },
        headers: {
          'x-auth-token': process.env.SETTLEMINT_APP_TOKEN
        }
      });
      
      return response.data;
    }
    ```
    
    **Content retrieval:**
    
    ```javascript
    // Get file content
    async function getIPFSContent(hash) {
      const response = await fetch(`https://ipfs.settlemint.com/api/v0/cat?arg=${hash}`, {
        headers: {
          'x-auth-token': process.env.SETTLEMINT_APP_TOKEN
        }
      });
      
      return response.text();
    }
    
    // Get file metadata
    async function getIPFSMetadata(hash) {
      const response = await fetch(`https://ipfs.settlemint.com/api/v0/object/stat?arg=${hash}`, {
        headers: {
          'x-auth-token': process.env.SETTLEMINT_APP_TOKEN
        }
      });
      
      return response.json();
    }
    
    // Stream large files
    async function streamIPFSFile(hash, outputPath) {
      const response = await fetch(`https://ipfs.settlemint.com/api/v0/get?arg=${hash}`, {
        headers: {
          'x-auth-token': process.env.SETTLEMINT_APP_TOKEN
        }
      });
      
      const fileStream = fs.createWriteStream(outputPath);
      response.body.pipe(fileStream);
      
      return new Promise((resolve, reject) => {
        fileStream.on('finish', resolve);
        fileStream.on('error', reject);
      });
    }
    ```
  </Tab>
  
  <Tab value="Graph indexers">
    **Query indexed data:**
    
    ```javascript
    const { gql, GraphQLClient } = require('graphql-request');
    
    // Initialize client for The Graph indexer
    const client = new GraphQLClient('https://graph.settlemint.com/subgraphs/name/your-subgraph', {
      headers: {
        'x-auth-token': process.env.SETTLEMINT_APP_TOKEN
      }
    });
    
    // Query token transfers
    const transfersQuery = gql`
      query GetTransfers($first: Int!, $where: Transfer_filter) {
        transfers(first: $first, where: $where, orderBy: timestamp, orderDirection: desc) {
          id
          from
          to
          value
          timestamp
          transaction {
            id
            gasUsed
            gasPrice
          }
        }
      }
    `;
    
    const transfers = await client.request(transfersQuery, {
      first: 100,
      where: {
        value_gte: '1000000000000000000' // Transfers >= 1 token
      }
    });
    
    // Query with pagination
    async function getAllTransfers(address) {
      let allTransfers = [];
      let lastId = '';
      
      while (true) {
        const query = gql`
          query GetTransfers($address: String!, $lastId: ID!) {
            transfers(
              first: 1000,
              where: { 
                or: [
                  { from: $address },
                  { to: $address }
                ],
                id_gt: $lastId
              }
            ) {
              id
              from
              to
              value
              timestamp
            }
          }
        `;
        
        const { transfers } = await client.request(query, { address, lastId });
        
        if (transfers.length === 0) break;
        
        allTransfers = [...allTransfers, ...transfers];
        lastId = transfers[transfers.length - 1].id;
      }
      
      return allTransfers;
    }
    
    // Subscribe to real-time updates (if supported)
    const subscription = gql`
      subscription OnTransfer($address: String!) {
        transfers(where: { to: $address }) {
          id
          from
          value
          timestamp
        }
      }
    `;
    ```
  </Tab>
</Tabs>

## Security best practices

### Token storage

<Callout type="error">
  **Never** commit tokens to version control or expose them in client-side code.
</Callout>

**Secure storage options**:

1. **Environment variables** (recommended for most applications)
   ```bash
   # .env file (add to .gitignore)
   SETTLEMINT_APP_TOKEN=your-token-here
   ```

2. **Secret management systems** (recommended for production)
   ```javascript
   // AWS Secrets Manager example
   const { SecretsManagerClient, GetSecretValueCommand } = require("@aws-sdk/client-secrets-manager");
   
   const client = new SecretsManagerClient();
   const command = new GetSecretValueCommand({
     SecretId: "settlemint/app-token"
   });
   const { SecretString } = await client.send(command);
   ```

3. **CI/CD secret variables**
   ```yaml
   # GitHub Actions example
   - name: Deploy to SettleMint
     env:
       SETTLEMINT_TOKEN: ${{ secrets.SETTLEMINT_APP_TOKEN }}
   ```

### Access patterns

Implement these security patterns in your applications:

1. **Token validation on startup**
   ```javascript
   async function validateToken() {
     try {
       const response = await fetch('https://api.settlemint.com/health', {
         headers: { 'x-auth-token': process.env.SETTLEMINT_APP_TOKEN }
       });
       if (!response.ok) throw new Error('Invalid token');
     } catch (error) {
       console.error('Token validation failed:', error);
       process.exit(1);
     }
   }
   ```

2. **Rate limiting and retry logic**
   ```javascript
   const rateLimiter = {
     attempts: 0,
     maxAttempts: 3,
     backoffMs: 1000,
     
     async execute(fn) {
       try {
         return await fn();
       } catch (error) {
         if (this.attempts < this.maxAttempts && error.status === 429) {
           this.attempts++;
           await new Promise(resolve => setTimeout(resolve, this.backoffMs * this.attempts));
           return this.execute(fn);
         }
         throw error;
       }
     }
   };
   ```

3. **Audit logging**
   ```javascript
   // Log all API interactions for compliance
   const auditLog = (method, endpoint, status) => {
     console.log(JSON.stringify({
       timestamp: new Date().toISOString(),
       method,
       endpoint,
       status,
       tokenId: process.env.SETTLEMINT_TOKEN_ID // Store token ID, not the token itself
     }));
   };
   ```

### Compliance considerations

- **PCI DSS**: Treat application tokens as sensitive authentication data
- **SOC 2**: Implement token rotation and access logging
- **GDPR**: Ensure tokens don't contain personal data
- **ISO 27001**: Follow documented token management procedures

## Monitoring and troubleshooting

### Common issues

| Issue | Cause | Solution |
|-------|-------|----------|
| 401 Unauthorized | Invalid or expired token | Verify token in dashboard, create new if expired |
| 403 Forbidden | Insufficient permissions | Check token scope includes required service |
| 429 Too Many Requests | Rate limit exceeded | Implement exponential backoff |
| 500 Internal Server Error | Service issue | Check SettleMint status page |

### Debug authentication issues

```javascript
// Debug helper for token issues
const debugAuth = async (token, service) => {
  console.log('Testing token for service:', service);
  
  try {
    const response = await fetch(`https://${service}.settlemint.com/health`, {
      headers: { 'x-auth-token': token }
    });
    
    console.log('Status:', response.status);
    console.log('Headers:', Object.fromEntries(response.headers));
    
    if (!response.ok) {
      const error = await response.text();
      console.log('Error:', error);
    }
  } catch (error) {
    console.error('Connection failed:', error);
  }
};
```

## Next steps

- Review our [security policies](/docs/security) for comprehensive security guidelines
- Set up [audit logs](/docs/platform-components/usage-and-logs/audit-logs) to track token usage
- Explore [personal access tokens](/docs/platform-components/security-and-authentication/personal-access-tokens) for development use
- Configure [monitoring tools](/docs/platform-components/usage-and-logs/monitoring-tools) for production deployments
